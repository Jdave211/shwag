{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///Users/davejaga/Desktop/Startups/shwag/website/src/app/api/avatar/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport sharp from 'sharp';\nimport { v4 as uuidv4 } from 'uuid';\nimport OpenAI from 'openai';\nimport heicConvert from 'heic-convert';\n\n// Initialize OpenAI client\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\n// Supported image formats\nconst SUPPORTED_FORMATS = ['jpeg', 'jpg', 'png', 'webp', 'heic'];\nconst MAX_IMAGE_SIZE = 4 * 1024 * 1024; // 4MB\n\n/**\n * Process image data into a format compatible with OpenAI\n * Handles various input formats and converts as needed\n */\nasync function processImage(imageData: string): Promise<string> {\n  try {\n    // Extract the base64 data from various possible formats\n    let base64Data = imageData;\n    if (base64Data.includes('base64,')) {\n      base64Data = base64Data.split('base64,')[1];\n    }\n\n    // Decode base64 to buffer\n    const buffer = Buffer.from(base64Data, 'base64');\n    \n    // Identify image format\n    const imageInfo = await sharp(buffer).metadata();\n    const format = imageInfo.format?.toLowerCase() || '';\n    \n    // Handle HEIC format specifically\n    if (format === 'heic') {\n      const convertedBuffer = await heicConvert({\n        buffer: buffer,\n        format: 'JPEG',\n        quality: 90\n      });\n      return `data:image/jpeg;base64,${Buffer.from(convertedBuffer).toString('base64')}`;\n    }\n    \n    // Process other formats with sharp\n    if (!SUPPORTED_FORMATS.includes(format)) {\n      // Convert to JPEG if format not supported\n      const processedBuffer = await sharp(buffer)\n        .jpeg({ quality: 90 })\n        .toBuffer();\n      return `data:image/jpeg;base64,${processedBuffer.toString('base64')}`;\n    }\n    \n    // Resize if image is too large\n    if (buffer.length > MAX_IMAGE_SIZE) {\n      const processedBuffer = await sharp(buffer)\n        .resize(1024, null, { fit: 'inside' })\n        .toBuffer();\n      return `data:image/${format};base64,${processedBuffer.toString('base64')}`;\n    }\n    \n    // Return properly formatted base64\n    return `data:image/${format};base64,${base64Data}`;\n  } catch (error) {\n    console.error('Image processing error:', error);\n    throw new Error('Failed to process image. Please ensure it is a valid image file.');\n  }\n}\n\n/**\n * Analyze physical characteristics using OpenAI vision model\n */\nasync function analyzePhysicalCharacteristics(\n  frontImage: string, \n  sideImage?: string,\n  measurements?: {\n    height?: number,\n    weight?: number,\n    chest?: number,\n    waist?: number,\n    hips?: number\n  }\n): Promise<any> {\n  try {\n    // Prepare messages for OpenAI\n    const messages = [\n      {\n        role: \"system\",\n        content: `You are an expert in physical characteristics analysis for avatar creation.\n        Extract detailed information about the person in the image to help create a digital avatar.\n        Focus on face shape, body proportions, distinctive features, skin tone, and other physical traits.\n        Your analysis should be structured and detailed enough for Metahuman-compatible character creation.\n        ${measurements ? 'Use the provided measurements as additional context: ' + JSON.stringify(measurements) : ''}\n        Return results in JSON format.`\n      },\n      {\n        role: \"user\",\n        content: [\n          { type: \"text\", text: \"Analyze this person's physical characteristics in detail for avatar creation:\" },\n          { type: \"image_url\", image_url: { url: frontImage } }\n        ]\n      }\n    ];\n    \n    // Add side image if provided\n    if (sideImage) {\n      messages[1].content.push(\n        { type: \"text\", text: \"Side view:\" },\n        { type: \"image_url\", image_url: { url: sideImage } }\n      );\n    }\n    \n    // Make API call to OpenAI\n    const response = await openai.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: messages as any,\n      response_format: { type: \"json_object\" },\n      max_tokens: 1500,\n    });\n    \n    // Parse and return the analysis\n    const analysisText = response.choices[0]?.message?.content || \"{}\";\n    return JSON.parse(analysisText);\n  } catch (error) {\n    console.error('OpenAI analysis error:', error);\n    throw new Error('Failed to analyze physical characteristics. Please try again later.');\n  }\n}\n\n/**\n * Generate avatar parameters based on the analysis\n */\nfunction generateAvatarParameters(analysisResult: any): any {\n  // Map analysis results to avatar parameters\n  // This would be customized based on your specific avatar system\n  const avatarParams = {\n    id: uuidv4(),\n    timestamp: new Date().toISOString(),\n    analysis: analysisResult,\n    metahumanParams: {\n      // Map analysis to specific Metahuman parameters\n      // This is a placeholder - actual mapping would depend on Metahuman API\n      faceShape: analysisResult.faceShape || 'oval',\n      skinTone: analysisResult.skinTone || 'medium',\n      eyeColor: analysisResult.eyeColor || 'brown',\n      hairStyle: analysisResult.hairStyle || 'short',\n      hairColor: analysisResult.hairColor || 'brown',\n      bodyType: analysisResult.bodyType || 'average',\n      // Additional parameters would be generated here\n    }\n  };\n  \n  return avatarParams;\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Parse the request body\n    const data = await request.json();\n    const { frontImage, sideImage, measurements } = data;\n    \n    // Validate request\n    if (!frontImage) {\n      return NextResponse.json({ error: 'Front image is required' }, { status: 400 });\n    }\n    \n    // Validate height is provided\n    if (!measurements || !measurements.height) {\n      return NextResponse.json({ error: 'Height measurement is required' }, { status: 400 });\n    }\n    \n    // Process images\n    const processedFrontImage = await processImage(frontImage);\n    let processedSideImage;\n    if (sideImage) {\n      processedSideImage = await processImage(sideImage);\n    }\n    \n    // Analyze physical characteristics\n    const analysisResult = await analyzePhysicalCharacteristics(\n      processedFrontImage, \n      processedSideImage, \n      measurements\n    );\n    \n    // Generate avatar parameters\n    const avatarParams = generateAvatarParameters(analysisResult);\n    \n    // Return the avatar generation result\n    return NextResponse.json({\n      success: true,\n      avatarId: avatarParams.id,\n      result: avatarParams\n    });\n    \n  } catch (error: any) {\n    console.error('Avatar generation error:', error);\n    \n    // Handle different error types\n    if (error.message.includes('OpenAI')) {\n      return NextResponse.json({ \n        error: 'Error communicating with AI service', \n        details: error.message \n      }, { status: 503 });\n    }\n    \n    if (error.message.includes('image')) {\n      return NextResponse.json({ \n        error: 'Image processing error', \n        details: error.message \n      }, { status: 400 });\n    }\n    \n    // Generic error response\n    return NextResponse.json({ \n      error: 'Failed to generate avatar', \n      details: error.message \n    }, { status: 500 });\n  }\n} "],"names":[],"mappings":"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","debugId":null}}]
}