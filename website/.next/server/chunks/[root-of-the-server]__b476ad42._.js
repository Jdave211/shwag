module.exports = {

"[project]/.next-internal/server/app/api/avatar/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/sharp [external] (sharp, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("sharp", () => require("sharp"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/punycode [external] (punycode, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/node:fs [external] (node:fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}}),
"[externals]/node:stream [external] (node:stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}}),
"[externals]/node:stream/web [external] (node:stream/web, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:stream/web", () => require("node:stream/web"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[project]/src/app/api/avatar/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "POST": (()=>POST)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$sharp__$5b$external$5d$__$28$sharp$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/sharp [external] (sharp, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v4$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm/v4.js [app-route] (ecmascript) <export default as v4>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/openai/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$heic$2d$convert$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/heic-convert/index.js [app-route] (ecmascript)");
;
;
;
;
;
// Initialize OpenAI client
const openai = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]({
    apiKey: process.env.OPENAI_API_KEY
});
// Supported image formats
const SUPPORTED_FORMATS = [
    'jpeg',
    'jpg',
    'png',
    'webp',
    'heic'
];
const MAX_IMAGE_SIZE = 4 * 1024 * 1024; // 4MB
/**
 * Process image data into a format compatible with OpenAI
 * Handles various input formats and converts as needed
 */ async function processImage(imageData) {
    try {
        // Extract the base64 data from various possible formats
        let base64Data = imageData;
        if (base64Data.includes('base64,')) {
            base64Data = base64Data.split('base64,')[1];
        }
        // Decode base64 to buffer
        const buffer = Buffer.from(base64Data, 'base64');
        // Identify image format
        const imageInfo = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$sharp__$5b$external$5d$__$28$sharp$2c$__cjs$29$__["default"])(buffer).metadata();
        const format = imageInfo.format?.toLowerCase() || '';
        // Handle HEIC format specifically
        if (format === 'heic') {
            const convertedBuffer = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$heic$2d$convert$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
                buffer: buffer,
                format: 'JPEG',
                quality: 90
            });
            return `data:image/jpeg;base64,${Buffer.from(convertedBuffer).toString('base64')}`;
        }
        // Process other formats with sharp
        if (!SUPPORTED_FORMATS.includes(format)) {
            // Convert to JPEG if format not supported
            const processedBuffer = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$sharp__$5b$external$5d$__$28$sharp$2c$__cjs$29$__["default"])(buffer).jpeg({
                quality: 90
            }).toBuffer();
            return `data:image/jpeg;base64,${processedBuffer.toString('base64')}`;
        }
        // Resize if image is too large
        if (buffer.length > MAX_IMAGE_SIZE) {
            const processedBuffer = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$sharp__$5b$external$5d$__$28$sharp$2c$__cjs$29$__["default"])(buffer).resize(1024, null, {
                fit: 'inside'
            }).toBuffer();
            return `data:image/${format};base64,${processedBuffer.toString('base64')}`;
        }
        // Return properly formatted base64
        return `data:image/${format};base64,${base64Data}`;
    } catch (error) {
        console.error('Image processing error:', error);
        throw new Error('Failed to process image. Please ensure it is a valid image file.');
    }
}
/**
 * Analyze physical characteristics using OpenAI vision model
 */ async function analyzePhysicalCharacteristics(frontImage, sideImage, measurements) {
    try {
        // Prepare messages for OpenAI
        const messages = [
            {
                role: "system",
                content: `You are an expert in physical characteristics analysis for avatar creation.
        Extract detailed information about the person in the image to help create a digital avatar.
        Focus on face shape, body proportions, distinctive features, skin tone, and other physical traits.
        Your analysis should be structured and detailed enough for Metahuman-compatible character creation.
        ${measurements ? 'Use the provided measurements as additional context: ' + JSON.stringify(measurements) : ''}
        Return results in JSON format.`
            },
            {
                role: "user",
                content: [
                    {
                        type: "text",
                        text: "Analyze this person's physical characteristics in detail for avatar creation:"
                    },
                    {
                        type: "image_url",
                        image_url: {
                            url: frontImage
                        }
                    }
                ]
            }
        ];
        // Add side image if provided
        if (sideImage) {
            messages[1].content.push({
                type: "text",
                text: "Side view:"
            }, {
                type: "image_url",
                image_url: {
                    url: sideImage
                }
            });
        }
        // Make API call to OpenAI
        const response = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: messages,
            response_format: {
                type: "json_object"
            },
            max_tokens: 1500
        });
        // Parse and return the analysis
        const analysisText = response.choices[0]?.message?.content || "{}";
        return JSON.parse(analysisText);
    } catch (error) {
        console.error('OpenAI analysis error:', error);
        throw new Error('Failed to analyze physical characteristics. Please try again later.');
    }
}
/**
 * Generate avatar parameters based on the analysis
 */ function generateAvatarParameters(analysisResult) {
    // Map analysis results to avatar parameters
    // This would be customized based on your specific avatar system
    const avatarParams = {
        id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2f$v4$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])(),
        timestamp: new Date().toISOString(),
        analysis: analysisResult,
        metahumanParams: {
            // Map analysis to specific Metahuman parameters
            // This is a placeholder - actual mapping would depend on Metahuman API
            faceShape: analysisResult.faceShape || 'oval',
            skinTone: analysisResult.skinTone || 'medium',
            eyeColor: analysisResult.eyeColor || 'brown',
            hairStyle: analysisResult.hairStyle || 'short',
            hairColor: analysisResult.hairColor || 'brown',
            bodyType: analysisResult.bodyType || 'average'
        }
    };
    return avatarParams;
}
async function POST(request) {
    try {
        // Parse the request body
        const data = await request.json();
        const { frontImage, sideImage, measurements } = data;
        // Validate request
        if (!frontImage) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Front image is required'
            }, {
                status: 400
            });
        }
        // Validate height is provided
        if (!measurements || !measurements.height) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Height measurement is required'
            }, {
                status: 400
            });
        }
        // Process images
        const processedFrontImage = await processImage(frontImage);
        let processedSideImage;
        if (sideImage) {
            processedSideImage = await processImage(sideImage);
        }
        // Analyze physical characteristics
        const analysisResult = await analyzePhysicalCharacteristics(processedFrontImage, processedSideImage, measurements);
        // Generate avatar parameters
        const avatarParams = generateAvatarParameters(analysisResult);
        // Return the avatar generation result
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            avatarId: avatarParams.id,
            result: avatarParams
        });
    } catch (error) {
        console.error('Avatar generation error:', error);
        // Handle different error types
        if (error.message.includes('OpenAI')) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Error communicating with AI service',
                details: error.message
            }, {
                status: 503
            });
        }
        if (error.message.includes('image')) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Image processing error',
                details: error.message
            }, {
                status: 400
            });
        }
        // Generic error response
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to generate avatar',
            details: error.message
        }, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__b476ad42._.js.map